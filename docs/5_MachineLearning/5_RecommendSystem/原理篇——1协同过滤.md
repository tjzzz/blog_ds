# 原理篇——近邻推荐

协同过滤，基于user-item的数据矩阵


即基于这个人消费过的，推荐相似的物品，或者是推荐相似人的消费物品
## 1.user based
- step1: 建立用户向量
因为用户-物品的矩阵是稀疏的，因此需要采取稀疏的数据存储方式。比如CSR, COO格式，scipy.sparse中的lil_matrix等

- step2: 计算用户两两之间的相似度,筛选每个用户的相似用户
实战中可能会碰到两个问题:
1) 向量维度太高，计算较慢。=>可以对向量进行采样计算， 另外是采用向量化计算，避免循环。
2) 数据量n太多，两两pair较大。
    * 可以将任务拆解成MR任务
    * 使用一些单机版的专门的工具，比如KGraph(https://github.com/aaalgo/kgraph), GraphCHI

- step3: 为每一个用户推荐结果

一些改进:
1. 对于基于用户的协同过滤有一些常见的改进办法，改进主要集中在用户对物品的喜欢程度上：惩罚对热门物品的喜欢程度，这是因为，热门的东西很难反应出用户的真实兴趣，更可能是被煽动，或者无聊随便点击的情形，这是群体行为常见特点；
2. 增加喜欢程度的时间衰减，一般使用一个指数函数，指数就是一个负数，值和喜欢行为发生时间间隔正相关即可，这很好理解，小时候喜欢的东西不代表我现在的口味，人都是会变的，这是人性。

## 2.item based

过程类似。
注意：如果采用cos相似度的话，可能会面临相似度的置信问题。比如(0,1,0,0)与(0,1,0,0) 对比(0,10,0,0)与(0,10,0,0)。
slop one算法： 对评分矩阵不是计算余弦相似度，而是计算距离
